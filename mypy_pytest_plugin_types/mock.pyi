from collections.abc import AsyncIterator, Callable, Iterable, Iterator, Sequence
from typing import (
    Any,
    Literal,
    Self,
    overload,
    type_check_only,
)
from unittest.mock import _Call, _CallList, _patch, _patch_dict, _patch_pass_arg

from _typeshed import MaybeNone

__all__ = (
    "AsyncMock",
    "MagicMock",
    "Mock",
    "NonCallableMagicMock",
    "NonCallableMock",
    "PropertyMock",
    "patch",
)

class NonCallableMock[**P, R]:
    def __new__(
        cls,
        spec: list[str] | object | type[object] | None = None,
        wraps: Callable[P, R] | None = None,
        name: str | None = None,
        spec_set: list[str] | object | type[object] | None = None,
        parent: NonCallableMock[..., Any] | None = None,
        _spec_state: Any | None = None,
        _new_name: str = "",
        _new_parent: NonCallableMock[..., Any] | None = None,
        _spec_as_instance: bool = False,
        _eat_self: bool | None = None,
        unsafe: bool = False,
        **kwargs: Any,
    ) -> Self: ...
    def __init__(
        self,
        spec: list[str] | object | type[object] | None = None,
        wraps: Any | None = None,
        name: str | None = None,
        spec_set: list[str] | object | type[object] | None = None,
        parent: NonCallableMock[..., Any] | None = None,
        _spec_state: Any | None = None,
        _new_name: str = "",
        _new_parent: NonCallableMock[..., Any] | None = None,
        _spec_as_instance: bool = False,
        _eat_self: bool | None = None,
        unsafe: bool = False,
        **kwargs: Any,
    ) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __delattr__(self, name: str) -> None: ...
    def __setattr__(self, name: str, value: Any) -> None: ...
    def __dir__(self) -> list[str]: ...
    def assert_called_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_not_called(self) -> None: ...
    def assert_called_once_with(self, *args: Any, **kwargs: Any) -> None: ...
    def _format_mock_failure_message(self, args: Any, kwargs: Any, action: str = "call") -> str: ...
    def assert_called(self) -> None: ...
    def assert_called_once(self) -> None: ...
    def reset_mock(
        self, visited: Any = None, *, return_value: bool = False, side_effect: bool = False
    ) -> None: ...
    def _extract_mock_name(self) -> str: ...
    def _get_call_signature_from_name(self, name: str) -> Any: ...
    def assert_any_call(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_has_calls(self, calls: Sequence[_Call], any_order: bool = False) -> None: ...
    def mock_add_spec(self, spec: Any, spec_set: bool = False) -> None: ...
    def _mock_add_spec(
        self, spec: Any, spec_set: bool, _spec_as_instance: bool = False, _eat_self: bool = False
    ) -> None: ...
    def attach_mock(self, mock: NonCallableMock[..., Any], attribute: str) -> None: ...
    def configure_mock(self, **kwargs: Any) -> None: ...
    return_value: R
    side_effect: Callable[P, R]
    called: bool
    call_count: int
    call_args: _Call | MaybeNone
    call_args_list: _CallList
    mock_calls: _CallList
    def _format_mock_call_signature(self, args: Any, kwargs: Any) -> str: ...
    def _call_matcher(self, _call: tuple[_Call, ...]) -> _Call: ...
    def _get_child_mock(self, **kw: Any) -> NonCallableMock[..., Any]: ...
    def _calls_repr(self) -> str: ...

class CallableMixin[**P, R]:
    side_effect: Callable[P, R]
    def __init__(
        self,
        spec: Any | None = None,
        side_effect: Callable[P, Any]
        | Iterable[R | Exception | type[Exception]]
        | Exception
        | type[Exception]
        | None = None,
        return_value: R = ...,
        wraps: Callable[P, R] | None = None,
        name: Any | None = None,
        spec_set: Any | None = None,
        parent: Any | None = None,
        _spec_state: Any | None = None,
        _new_name: Any = "",
        _new_parent: Any | None = None,
        **kwargs: Any,
    ) -> None: ...
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...

class Mock[**P, R](CallableMixin[P, R], NonCallableMock[P, R]): ...

# This class does not exist at runtime, it's a hack to add methods to the
# patch() function.
@type_check_only
class _patcher[T]:  # noqa: N801
    TEST_PREFIX: str
    dict: type[_patch_dict]
    # This overload also covers the case, where new==DEFAULT. In this case, the return type is _patch[Any].
    # Ideally we'd be able to add an overload for it so that the return type is _patch[MagicMock],
    # but that's impossible with the current type system.
    @overload
    def __call__(  # type: ignore[overload-overlap]
        self,
        target: str,
        new: T,
        spec: Literal[False] | None = None,
        create: bool = False,
        spec_set: Literal[False] | None = None,
        autospec: Literal[False] | None = None,
        new_callable: None = None,
        *,
        unsafe: bool = False,
    ) -> _patch[T]: ...
    @overload
    def __call__(
        self,
        target: str,
        *,
        # If not False or None, this is passed to new_callable
        spec: Any | Literal[False] | None = None,
        create: bool = False,
        # If not False or None, this is passed to new_callable
        spec_set: Any | Literal[False] | None = None,
        autospec: Literal[False] | None = None,
        new_callable: Callable[..., T],
        unsafe: bool = False,
        # kwargs are passed to new_callable
        **kwargs: Any,
    ) -> _patch_pass_arg[T]: ...
    @overload
    def __call__(
        self,
        target: str,
        *,
        spec: Any | bool | None = None,
        create: bool = False,
        spec_set: Any | bool | None = None,
        autospec: Any | bool | None = None,
        new_callable: None = None,
        unsafe: bool = False,
        # kwargs are passed to the MagicMock/AsyncMock constructor
        **kwargs: Any,
    ) -> _patch_pass_arg[MagicMock[..., Any] | AsyncMock[..., Any]]: ...
    # This overload also covers the case, where new==DEFAULT. In this case, the return type is _patch[Any].
    # Ideally we'd be able to add an overload for it so that the return type is _patch[MagicMock],
    # but that's impossible with the current type system.
    @overload
    @staticmethod
    def object(
        target: Any,
        attribute: str,
        new: T,
        spec: Literal[False] | None = None,
        create: bool = False,
        spec_set: Literal[False] | None = None,
        autospec: Literal[False] | None = None,
        new_callable: None = None,
        *,
        unsafe: bool = False,
    ) -> _patch[T]: ...
    @overload
    @staticmethod
    def object(
        target: Any,
        attribute: str,
        *,
        # If not False or None, this is passed to new_callable
        spec: Any | Literal[False] | None = None,
        create: bool = False,
        # If not False or None, this is passed to new_callable
        spec_set: Any | Literal[False] | None = None,
        autospec: Literal[False] | None = None,
        new_callable: Callable[..., T],
        unsafe: bool = False,
        # kwargs are passed to new_callable
        **kwargs: Any,
    ) -> _patch_pass_arg[T]: ...
    @overload
    @staticmethod
    def object(
        target: Any,
        attribute: str,
        *,
        spec: Any | bool | None = None,
        create: bool = False,
        spec_set: Any | bool | None = None,
        autospec: Any | bool | None = None,
        new_callable: None = None,
        unsafe: bool = False,
        # kwargs are passed to the MagicMock/AsyncMock constructor
        **kwargs: Any,
    ) -> _patch_pass_arg[MagicMock[..., Any] | AsyncMock[..., Any]]: ...
    @overload
    @staticmethod
    def multiple(
        target: Any | str,
        # If not False or None, this is passed to new_callable
        spec: Any | Literal[False] | None = None,
        create: bool = False,
        # If not False or None, this is passed to new_callable
        spec_set: Any | Literal[False] | None = None,
        autospec: Literal[False] | None = None,
        *,
        new_callable: Callable[..., T],
        # The kwargs must be DEFAULT
        **kwargs: Any,
    ) -> _patch_pass_arg[T]: ...
    @overload
    @staticmethod
    def multiple(
        target: Any | str,
        # If not False or None, this is passed to new_callable
        spec: Any | Literal[False] | None,
        create: bool,
        # If not False or None, this is passed to new_callable
        spec_set: Any | Literal[False] | None,
        autospec: Literal[False] | None,
        new_callable: Callable[..., T],
        # The kwargs must be DEFAULT
        **kwargs: Any,
    ) -> _patch_pass_arg[T]: ...
    @overload
    @staticmethod
    def multiple(
        target: Any | str,
        spec: Any | bool | None = None,
        create: bool = False,
        spec_set: Any | bool | None = None,
        autospec: Any | bool | None = None,
        new_callable: None = None,
        # The kwargs are the mock objects or DEFAULT
        **kwargs: Any,
    ) -> _patch[Any]: ...
    @staticmethod
    def stopall() -> None: ...

patch: _patcher[Any]

class MagicMixin:
    def __lt__(self, other: object) -> Any: ...
    def __gt__(self, other: object) -> Any: ...
    def __ge__(self, other: object) -> Any: ...
    def __le__(self, other: object) -> Any: ...
    def __int__(self) -> Literal[1]: ...
    def __containts__(self) -> Literal[False]: ...
    def __len__(self) -> Literal[0]: ...
    def __exit__(self, exctype: object, excinst: object, exctb: object, /) -> Literal[False]: ...
    def __aexit__(self, exctype: object, excinst: object, exctb: object, /) -> Literal[False]: ...
    def __next__(self) -> Self: ...
    def __anext__(self) -> AsyncMockMixin: ...
    def __complex__(self) -> complex: ...
    def __float__(self) -> float: ...
    def __bool__(self) -> Literal[True]: ...
    def __index__(self) -> Literal[1]: ...
    def __hash__(self) -> int: ...
    def __sizeof__(self) -> int: ...
    def __fspath__(self) -> str: ...
    def __eq__(self, other: object, /) -> Any: ...
    def __ne__(self, other: object, /) -> Any: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __aiter__(self) -> AsyncIterator[Any]: ...
    def __abs__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __add__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __aenter__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __and__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ceil__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __delitem__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __divmod__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __enter__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __floor__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __floordiv__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __getitem__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __iadd__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __iand__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ifloordiv__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ilshift__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __imatmul__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __imod__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __imul__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __invert__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ior__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ipow__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __irshift__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __isub__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __itruediv__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ixor__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __lshift__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __matmul__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __mod__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __mul__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __neg__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __or__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __pos__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __pow__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __radd__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rand__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rdivmod__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rfloordiv__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rlshift__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rmatmul__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rmod__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rmul__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __ror__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __round__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rpow__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rrshift__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rshift__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rsub__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rtruediv__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __rxor__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __setitem__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __sub__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __truediv__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __trunc__(self, *args: Any, **kwargs: Any) -> Self: ...
    def __xor__(self, *args: Any, **kwargs: Any) -> Self: ...

class NonCallableMagicMock[**P, R](MagicMixin, NonCallableMock[P, R]): ...
class MagicMock[**P, R](MagicMixin, Mock[P, R]): ...

class AsyncMockMixin:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    async def _execute_mock_call(self, *args: Any, **kwargs: Any) -> Any: ...
    def assert_awaited(self) -> None: ...
    def assert_awaited_once(self) -> None: ...
    def assert_awaited_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_awaited_once_with(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_any_await(self, *args: Any, **kwargs: Any) -> None: ...
    def assert_has_awaits(self, calls: Iterable[_Call], any_order: bool = False) -> None: ...
    def assert_not_awaited(self) -> None: ...
    def reset_mock(self, *args: Any, **kwargs: Any) -> None: ...
    await_count: int
    await_args: _Call | None
    await_args_list: _CallList

class AsyncMagicMixin(MagicMixin): ...

class AsyncMock[**P, R](AsyncMockMixin, AsyncMagicMixin, Mock[P, R]):
    # Improving the `reset_mock` signature.
    # It is defined on `AsyncMockMixin` with `*args, **kwargs`, which is not ideal.
    # But, `NonCallableMock` super-class has the better version.
    def reset_mock(
        self, visited: Any = None, *, return_value: bool = False, side_effect: bool = False
    ) -> None: ...

class MagicProxy:
    name: str
    parent: Any
    def __init__(self, name: str, parent: Any) -> None: ...
    def create_mock(self) -> Any: ...
    def __get__(self, obj: Any, _type: Any | None = None) -> Any: ...

class PropertyMock[T](Mock[..., T]):
    def __get__(self, obj: T, obj_type: type[T] | None = None) -> Self: ...
    def __set__(self, obj: Any, val: T) -> None: ...
